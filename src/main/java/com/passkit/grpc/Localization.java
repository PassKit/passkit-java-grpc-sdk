// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: io/common/localization.proto
// Protobuf Java Version: 4.29.0

package com.passkit.grpc;

public final class Localization {
  private Localization() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 29,
      /* patch= */ 0,
      /* suffix= */ "",
      Localization.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * This is a list of supported languages.
   * </pre>
   *
   * Protobuf enum {@code io.LanguageCode}
   */
  public enum LanguageCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * English
     * </pre>
     *
     * <code>EN = 0;</code>
     */
    EN(0),
    /**
     * <pre>
     * (Arabic) العربية
     * </pre>
     *
     * <code>AR = 4;</code>
     */
    AR(4),
    /**
     * <pre>
     * 简体中文 (Chinese)
     * </pre>
     *
     * <code>ZH_HANS = 8;</code>
     */
    ZH_HANS(8),
    /**
     * <pre>
     * 繁體中文 (Traditional Chinese)
     * </pre>
     *
     * <code>ZH_HANT = 12;</code>
     */
    ZH_HANT(12),
    /**
     * <pre>
     * 香港中文 (Cantonese)
     * </pre>
     *
     * <code>ZH_HK = 16;</code>
     */
    ZH_HK(16),
    /**
     * <pre>
     * Català (Catalan)
     * </pre>
     *
     * <code>CA = 20;</code>
     */
    CA(20),
    /**
     * <pre>
     * Hrvatski (Croatian)
     * </pre>
     *
     * <code>HR = 24;</code>
     */
    HR(24),
    /**
     * <pre>
     * Čeština (Czech)
     * </pre>
     *
     * <code>CS = 28;</code>
     */
    CS(28),
    /**
     * <pre>
     * Dansk (Danish)
     * </pre>
     *
     * <code>DA = 32;</code>
     */
    DA(32),
    /**
     * <pre>
     * Deutsch (German)
     * </pre>
     *
     * <code>DE = 36;</code>
     */
    DE(36),
    /**
     * <pre>
     * English (Australia)
     * </pre>
     *
     * <code>EN_AU = 40;</code>
     */
    EN_AU(40),
    /**
     * <pre>
     * English (British)
     * </pre>
     *
     * <code>EN_GB = 44;</code>
     */
    EN_GB(44),
    /**
     * <pre>
     * English (Canada)
     * </pre>
     *
     * <code>EN_CA = 48;</code>
     */
    EN_CA(48),
    /**
     * <pre>
     * English (India)
     * </pre>
     *
     * <code>EN_US = 52;</code>
     */
    EN_US(52),
    /**
     * <pre>
     * English (United States)
     * </pre>
     *
     * <code>EN_IN = 56;</code>
     */
    EN_IN(56),
    /**
     * <pre>
     * Español (Spanish)
     * </pre>
     *
     * <code>ES = 60;</code>
     */
    ES(60),
    /**
     * <pre>
     * Español (Latin America)
     * </pre>
     *
     * <code>ES_419 = 64;</code>
     */
    ES_419(64),
    /**
     * <pre>
     * Suomi (Finnish)
     * </pre>
     *
     * <code>FI = 68;</code>
     */
    FI(68),
    /**
     * <pre>
     * Français (French)
     * </pre>
     *
     * <code>FR = 72;</code>
     */
    FR(72),
    /**
     * <pre>
     * Français (Canada)
     * </pre>
     *
     * <code>FR_CA = 76;</code>
     */
    FR_CA(76),
    /**
     * <pre>
     * Ελληνικά (Greek)
     * </pre>
     *
     * <code>EL = 80;</code>
     */
    EL(80),
    /**
     * <pre>
     * (Hebrew) עברית
     * </pre>
     *
     * <code>HE = 84;</code>
     */
    HE(84),
    /**
     * <pre>
     * हिन्दी (Hindi)
     * </pre>
     *
     * <code>HI = 88;</code>
     */
    HI(88),
    /**
     * <pre>
     * Magyar (Hungarian)
     * </pre>
     *
     * <code>HU = 92;</code>
     */
    HU(92),
    /**
     * <pre>
     * Bahasa Indonesia (Indonesian)
     * </pre>
     *
     * <code>ID = 96;</code>
     */
    ID(96),
    /**
     * <pre>
     * Italiano (Italian)
     * </pre>
     *
     * <code>IT = 100;</code>
     */
    IT(100),
    /**
     * <pre>
     * 日本語 (Japanese)
     * </pre>
     *
     * <code>JA = 104;</code>
     */
    JA(104),
    /**
     * <pre>
     * 한국어 (Korean)
     * </pre>
     *
     * <code>KO = 108;</code>
     */
    KO(108),
    /**
     * <pre>
     * Bahasa Melayu (Malay)
     * </pre>
     *
     * <code>MS = 112;</code>
     */
    MS(112),
    /**
     * <pre>
     * Malti (Maltese)
     * </pre>
     *
     * <code>MT = 116;</code>
     */
    MT(116),
    /**
     * <pre>
     * Nederlands (Dutch)
     * </pre>
     *
     * <code>NL = 120;</code>
     */
    NL(120),
    /**
     * <pre>
     * Norsk Bokmål (Norwegian)
     * </pre>
     *
     * <code>NB = 124;</code>
     */
    NB(124),
    /**
     * <pre>
     * Polski (Polish)
     * </pre>
     *
     * <code>PL = 128;</code>
     */
    PL(128),
    /**
     * <pre>
     * Português de Portugal (Portuguese)
     * </pre>
     *
     * <code>PT = 132;</code>
     */
    PT(132),
    /**
     * <pre>
     * Português (Brazilian Portuguese)
     * </pre>
     *
     * <code>PT_BR = 136;</code>
     */
    PT_BR(136),
    /**
     * <pre>
     * Română (Romanian)
     * </pre>
     *
     * <code>RO = 140;</code>
     */
    RO(140),
    /**
     * <pre>
     * Русский (Russian)
     * </pre>
     *
     * <code>RU = 144;</code>
     */
    RU(144),
    /**
     * <pre>
     * Slovenčina (Slovakian)
     * </pre>
     *
     * <code>SK = 148;</code>
     */
    SK(148),
    /**
     * <pre>
     * Svenska (Swedish)
     * </pre>
     *
     * <code>SV = 152;</code>
     */
    SV(152),
    /**
     * <pre>
     * ภาษาไทย (Thai)
     * </pre>
     *
     * <code>TH = 156;</code>
     */
    TH(156),
    /**
     * <pre>
     * Türkçe (Turkish)
     * </pre>
     *
     * <code>TR = 160;</code>
     */
    TR(160),
    /**
     * <pre>
     * Українська (Ukrainian)
     * </pre>
     *
     * <code>UK = 164;</code>
     */
    UK(164),
    /**
     * <pre>
     * Tiếng Việt (Vietnamese)
     * </pre>
     *
     * <code>VI = 168;</code>
     */
    VI(168),
    UNRECOGNIZED(-1),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 0,
        /* suffix= */ "",
        LanguageCode.class.getName());
    }
    /**
     * <pre>
     * English
     * </pre>
     *
     * <code>EN = 0;</code>
     */
    public static final int EN_VALUE = 0;
    /**
     * <pre>
     * (Arabic) العربية
     * </pre>
     *
     * <code>AR = 4;</code>
     */
    public static final int AR_VALUE = 4;
    /**
     * <pre>
     * 简体中文 (Chinese)
     * </pre>
     *
     * <code>ZH_HANS = 8;</code>
     */
    public static final int ZH_HANS_VALUE = 8;
    /**
     * <pre>
     * 繁體中文 (Traditional Chinese)
     * </pre>
     *
     * <code>ZH_HANT = 12;</code>
     */
    public static final int ZH_HANT_VALUE = 12;
    /**
     * <pre>
     * 香港中文 (Cantonese)
     * </pre>
     *
     * <code>ZH_HK = 16;</code>
     */
    public static final int ZH_HK_VALUE = 16;
    /**
     * <pre>
     * Català (Catalan)
     * </pre>
     *
     * <code>CA = 20;</code>
     */
    public static final int CA_VALUE = 20;
    /**
     * <pre>
     * Hrvatski (Croatian)
     * </pre>
     *
     * <code>HR = 24;</code>
     */
    public static final int HR_VALUE = 24;
    /**
     * <pre>
     * Čeština (Czech)
     * </pre>
     *
     * <code>CS = 28;</code>
     */
    public static final int CS_VALUE = 28;
    /**
     * <pre>
     * Dansk (Danish)
     * </pre>
     *
     * <code>DA = 32;</code>
     */
    public static final int DA_VALUE = 32;
    /**
     * <pre>
     * Deutsch (German)
     * </pre>
     *
     * <code>DE = 36;</code>
     */
    public static final int DE_VALUE = 36;
    /**
     * <pre>
     * English (Australia)
     * </pre>
     *
     * <code>EN_AU = 40;</code>
     */
    public static final int EN_AU_VALUE = 40;
    /**
     * <pre>
     * English (British)
     * </pre>
     *
     * <code>EN_GB = 44;</code>
     */
    public static final int EN_GB_VALUE = 44;
    /**
     * <pre>
     * English (Canada)
     * </pre>
     *
     * <code>EN_CA = 48;</code>
     */
    public static final int EN_CA_VALUE = 48;
    /**
     * <pre>
     * English (India)
     * </pre>
     *
     * <code>EN_US = 52;</code>
     */
    public static final int EN_US_VALUE = 52;
    /**
     * <pre>
     * English (United States)
     * </pre>
     *
     * <code>EN_IN = 56;</code>
     */
    public static final int EN_IN_VALUE = 56;
    /**
     * <pre>
     * Español (Spanish)
     * </pre>
     *
     * <code>ES = 60;</code>
     */
    public static final int ES_VALUE = 60;
    /**
     * <pre>
     * Español (Latin America)
     * </pre>
     *
     * <code>ES_419 = 64;</code>
     */
    public static final int ES_419_VALUE = 64;
    /**
     * <pre>
     * Suomi (Finnish)
     * </pre>
     *
     * <code>FI = 68;</code>
     */
    public static final int FI_VALUE = 68;
    /**
     * <pre>
     * Français (French)
     * </pre>
     *
     * <code>FR = 72;</code>
     */
    public static final int FR_VALUE = 72;
    /**
     * <pre>
     * Français (Canada)
     * </pre>
     *
     * <code>FR_CA = 76;</code>
     */
    public static final int FR_CA_VALUE = 76;
    /**
     * <pre>
     * Ελληνικά (Greek)
     * </pre>
     *
     * <code>EL = 80;</code>
     */
    public static final int EL_VALUE = 80;
    /**
     * <pre>
     * (Hebrew) עברית
     * </pre>
     *
     * <code>HE = 84;</code>
     */
    public static final int HE_VALUE = 84;
    /**
     * <pre>
     * हिन्दी (Hindi)
     * </pre>
     *
     * <code>HI = 88;</code>
     */
    public static final int HI_VALUE = 88;
    /**
     * <pre>
     * Magyar (Hungarian)
     * </pre>
     *
     * <code>HU = 92;</code>
     */
    public static final int HU_VALUE = 92;
    /**
     * <pre>
     * Bahasa Indonesia (Indonesian)
     * </pre>
     *
     * <code>ID = 96;</code>
     */
    public static final int ID_VALUE = 96;
    /**
     * <pre>
     * Italiano (Italian)
     * </pre>
     *
     * <code>IT = 100;</code>
     */
    public static final int IT_VALUE = 100;
    /**
     * <pre>
     * 日本語 (Japanese)
     * </pre>
     *
     * <code>JA = 104;</code>
     */
    public static final int JA_VALUE = 104;
    /**
     * <pre>
     * 한국어 (Korean)
     * </pre>
     *
     * <code>KO = 108;</code>
     */
    public static final int KO_VALUE = 108;
    /**
     * <pre>
     * Bahasa Melayu (Malay)
     * </pre>
     *
     * <code>MS = 112;</code>
     */
    public static final int MS_VALUE = 112;
    /**
     * <pre>
     * Malti (Maltese)
     * </pre>
     *
     * <code>MT = 116;</code>
     */
    public static final int MT_VALUE = 116;
    /**
     * <pre>
     * Nederlands (Dutch)
     * </pre>
     *
     * <code>NL = 120;</code>
     */
    public static final int NL_VALUE = 120;
    /**
     * <pre>
     * Norsk Bokmål (Norwegian)
     * </pre>
     *
     * <code>NB = 124;</code>
     */
    public static final int NB_VALUE = 124;
    /**
     * <pre>
     * Polski (Polish)
     * </pre>
     *
     * <code>PL = 128;</code>
     */
    public static final int PL_VALUE = 128;
    /**
     * <pre>
     * Português de Portugal (Portuguese)
     * </pre>
     *
     * <code>PT = 132;</code>
     */
    public static final int PT_VALUE = 132;
    /**
     * <pre>
     * Português (Brazilian Portuguese)
     * </pre>
     *
     * <code>PT_BR = 136;</code>
     */
    public static final int PT_BR_VALUE = 136;
    /**
     * <pre>
     * Română (Romanian)
     * </pre>
     *
     * <code>RO = 140;</code>
     */
    public static final int RO_VALUE = 140;
    /**
     * <pre>
     * Русский (Russian)
     * </pre>
     *
     * <code>RU = 144;</code>
     */
    public static final int RU_VALUE = 144;
    /**
     * <pre>
     * Slovenčina (Slovakian)
     * </pre>
     *
     * <code>SK = 148;</code>
     */
    public static final int SK_VALUE = 148;
    /**
     * <pre>
     * Svenska (Swedish)
     * </pre>
     *
     * <code>SV = 152;</code>
     */
    public static final int SV_VALUE = 152;
    /**
     * <pre>
     * ภาษาไทย (Thai)
     * </pre>
     *
     * <code>TH = 156;</code>
     */
    public static final int TH_VALUE = 156;
    /**
     * <pre>
     * Türkçe (Turkish)
     * </pre>
     *
     * <code>TR = 160;</code>
     */
    public static final int TR_VALUE = 160;
    /**
     * <pre>
     * Українська (Ukrainian)
     * </pre>
     *
     * <code>UK = 164;</code>
     */
    public static final int UK_VALUE = 164;
    /**
     * <pre>
     * Tiếng Việt (Vietnamese)
     * </pre>
     *
     * <code>VI = 168;</code>
     */
    public static final int VI_VALUE = 168;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static LanguageCode valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static LanguageCode forNumber(int value) {
      switch (value) {
        case 0: return EN;
        case 4: return AR;
        case 8: return ZH_HANS;
        case 12: return ZH_HANT;
        case 16: return ZH_HK;
        case 20: return CA;
        case 24: return HR;
        case 28: return CS;
        case 32: return DA;
        case 36: return DE;
        case 40: return EN_AU;
        case 44: return EN_GB;
        case 48: return EN_CA;
        case 52: return EN_US;
        case 56: return EN_IN;
        case 60: return ES;
        case 64: return ES_419;
        case 68: return FI;
        case 72: return FR;
        case 76: return FR_CA;
        case 80: return EL;
        case 84: return HE;
        case 88: return HI;
        case 92: return HU;
        case 96: return ID;
        case 100: return IT;
        case 104: return JA;
        case 108: return KO;
        case 112: return MS;
        case 116: return MT;
        case 120: return NL;
        case 124: return NB;
        case 128: return PL;
        case 132: return PT;
        case 136: return PT_BR;
        case 140: return RO;
        case 144: return RU;
        case 148: return SK;
        case 152: return SV;
        case 156: return TH;
        case 160: return TR;
        case 164: return UK;
        case 168: return VI;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<LanguageCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        LanguageCode> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<LanguageCode>() {
            public LanguageCode findValueByNumber(int number) {
              return LanguageCode.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return com.passkit.grpc.Localization.getDescriptor().getEnumTypes().get(0);
    }

    private static final LanguageCode[] VALUES = values();

    public static LanguageCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private LanguageCode(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:io.LanguageCode)
  }

  public interface LocalizedStringOrBuilder extends
      // @@protoc_insertion_point(interface_extends:io.LocalizedString)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    int getTranslationsCount();
    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    boolean containsTranslations(
        java.lang.String key);
    /**
     * Use {@link #getTranslationsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getTranslations();
    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getTranslationsMap();
    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    /* nullable */
java.lang.String getTranslationsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue);
    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    java.lang.String getTranslationsOrThrow(
        java.lang.String key);
  }
  /**
   * <pre>
   * Localized strings are optionally used to provide translated values for each of supported language.
   * </pre>
   *
   * Protobuf type {@code io.LocalizedString}
   */
  public static final class LocalizedString extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:io.LocalizedString)
      LocalizedStringOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 0,
        /* suffix= */ "",
        LocalizedString.class.getName());
    }
    // Use LocalizedString.newBuilder() to construct.
    private LocalizedString(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private LocalizedString() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.passkit.grpc.Localization.internal_static_io_LocalizedString_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
        int number) {
      switch (number) {
        case 1:
          return internalGetTranslations();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.passkit.grpc.Localization.internal_static_io_LocalizedString_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.passkit.grpc.Localization.LocalizedString.class, com.passkit.grpc.Localization.LocalizedString.Builder.class);
    }

    public static final int TRANSLATIONS_FIELD_NUMBER = 1;
    private static final class TranslationsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  com.passkit.grpc.Localization.internal_static_io_LocalizedString_TranslationsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    @SuppressWarnings("serial")
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> translations_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetTranslations() {
      if (translations_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            TranslationsDefaultEntryHolder.defaultEntry);
      }
      return translations_;
    }
    public int getTranslationsCount() {
      return internalGetTranslations().getMap().size();
    }
    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    @java.lang.Override
    public boolean containsTranslations(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetTranslations().getMap().containsKey(key);
    }
    /**
     * Use {@link #getTranslationsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getTranslations() {
      return getTranslationsMap();
    }
    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    @java.lang.Override
    public java.util.Map<java.lang.String, java.lang.String> getTranslationsMap() {
      return internalGetTranslations().getMap();
    }
    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    @java.lang.Override
    public /* nullable */
java.lang.String getTranslationsOrDefault(
        java.lang.String key,
        /* nullable */
java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetTranslations().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Translations key is a valid LanguageCode. The value represents the translated string.
     * </pre>
     *
     * <code>map&lt;string, string&gt; translations = 1;</code>
     */
    @java.lang.Override
    public java.lang.String getTranslationsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetTranslations().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessage
        .serializeStringMapTo(
          output,
          internalGetTranslations(),
          TranslationsDefaultEntryHolder.defaultEntry,
          1);
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetTranslations().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        translations__ = TranslationsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, translations__);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof com.passkit.grpc.Localization.LocalizedString)) {
        return super.equals(obj);
      }
      com.passkit.grpc.Localization.LocalizedString other = (com.passkit.grpc.Localization.LocalizedString) obj;

      if (!internalGetTranslations().equals(
          other.internalGetTranslations())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetTranslations().getMap().isEmpty()) {
        hash = (37 * hash) + TRANSLATIONS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetTranslations().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static com.passkit.grpc.Localization.LocalizedString parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static com.passkit.grpc.Localization.LocalizedString parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static com.passkit.grpc.Localization.LocalizedString parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static com.passkit.grpc.Localization.LocalizedString parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.passkit.grpc.Localization.LocalizedString prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Localized strings are optionally used to provide translated values for each of supported language.
     * </pre>
     *
     * Protobuf type {@code io.LocalizedString}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:io.LocalizedString)
        com.passkit.grpc.Localization.LocalizedStringOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return com.passkit.grpc.Localization.internal_static_io_LocalizedString_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetTranslations();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapFieldReflectionAccessor internalGetMutableMapFieldReflection(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableTranslations();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return com.passkit.grpc.Localization.internal_static_io_LocalizedString_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                com.passkit.grpc.Localization.LocalizedString.class, com.passkit.grpc.Localization.LocalizedString.Builder.class);
      }

      // Construct using com.passkit.grpc.Localization.LocalizedString.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        internalGetMutableTranslations().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return com.passkit.grpc.Localization.internal_static_io_LocalizedString_descriptor;
      }

      @java.lang.Override
      public com.passkit.grpc.Localization.LocalizedString getDefaultInstanceForType() {
        return com.passkit.grpc.Localization.LocalizedString.getDefaultInstance();
      }

      @java.lang.Override
      public com.passkit.grpc.Localization.LocalizedString build() {
        com.passkit.grpc.Localization.LocalizedString result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public com.passkit.grpc.Localization.LocalizedString buildPartial() {
        com.passkit.grpc.Localization.LocalizedString result = new com.passkit.grpc.Localization.LocalizedString(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(com.passkit.grpc.Localization.LocalizedString result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.translations_ = internalGetTranslations();
          result.translations_.makeImmutable();
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof com.passkit.grpc.Localization.LocalizedString) {
          return mergeFrom((com.passkit.grpc.Localization.LocalizedString)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(com.passkit.grpc.Localization.LocalizedString other) {
        if (other == com.passkit.grpc.Localization.LocalizedString.getDefaultInstance()) return this;
        internalGetMutableTranslations().mergeFrom(
            other.internalGetTranslations());
        bitField0_ |= 0x00000001;
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                translations__ = input.readMessage(
                    TranslationsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                internalGetMutableTranslations().getMutableMap().put(
                    translations__.getKey(), translations__.getValue());
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> translations_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetTranslations() {
        if (translations_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              TranslationsDefaultEntryHolder.defaultEntry);
        }
        return translations_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
          internalGetMutableTranslations() {
        if (translations_ == null) {
          translations_ = com.google.protobuf.MapField.newMapField(
              TranslationsDefaultEntryHolder.defaultEntry);
        }
        if (!translations_.isMutable()) {
          translations_ = translations_.copy();
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return translations_;
      }
      public int getTranslationsCount() {
        return internalGetTranslations().getMap().size();
      }
      /**
       * <pre>
       * Translations key is a valid LanguageCode. The value represents the translated string.
       * </pre>
       *
       * <code>map&lt;string, string&gt; translations = 1;</code>
       */
      @java.lang.Override
      public boolean containsTranslations(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetTranslations().getMap().containsKey(key);
      }
      /**
       * Use {@link #getTranslationsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getTranslations() {
        return getTranslationsMap();
      }
      /**
       * <pre>
       * Translations key is a valid LanguageCode. The value represents the translated string.
       * </pre>
       *
       * <code>map&lt;string, string&gt; translations = 1;</code>
       */
      @java.lang.Override
      public java.util.Map<java.lang.String, java.lang.String> getTranslationsMap() {
        return internalGetTranslations().getMap();
      }
      /**
       * <pre>
       * Translations key is a valid LanguageCode. The value represents the translated string.
       * </pre>
       *
       * <code>map&lt;string, string&gt; translations = 1;</code>
       */
      @java.lang.Override
      public /* nullable */
java.lang.String getTranslationsOrDefault(
          java.lang.String key,
          /* nullable */
java.lang.String defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetTranslations().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Translations key is a valid LanguageCode. The value represents the translated string.
       * </pre>
       *
       * <code>map&lt;string, string&gt; translations = 1;</code>
       */
      @java.lang.Override
      public java.lang.String getTranslationsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetTranslations().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      public Builder clearTranslations() {
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableTranslations().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Translations key is a valid LanguageCode. The value represents the translated string.
       * </pre>
       *
       * <code>map&lt;string, string&gt; translations = 1;</code>
       */
      public Builder removeTranslations(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableTranslations().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
          getMutableTranslations() {
        bitField0_ |= 0x00000001;
        return internalGetMutableTranslations().getMutableMap();
      }
      /**
       * <pre>
       * Translations key is a valid LanguageCode. The value represents the translated string.
       * </pre>
       *
       * <code>map&lt;string, string&gt; translations = 1;</code>
       */
      public Builder putTranslations(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) { throw new NullPointerException("map value"); }
        internalGetMutableTranslations().getMutableMap()
            .put(key, value);
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Translations key is a valid LanguageCode. The value represents the translated string.
       * </pre>
       *
       * <code>map&lt;string, string&gt; translations = 1;</code>
       */
      public Builder putAllTranslations(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableTranslations().getMutableMap()
            .putAll(values);
        bitField0_ |= 0x00000001;
        return this;
      }

      // @@protoc_insertion_point(builder_scope:io.LocalizedString)
    }

    // @@protoc_insertion_point(class_scope:io.LocalizedString)
    private static final com.passkit.grpc.Localization.LocalizedString DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new com.passkit.grpc.Localization.LocalizedString();
    }

    public static com.passkit.grpc.Localization.LocalizedString getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<LocalizedString>
        PARSER = new com.google.protobuf.AbstractParser<LocalizedString>() {
      @java.lang.Override
      public LocalizedString parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<LocalizedString> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<LocalizedString> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public com.passkit.grpc.Localization.LocalizedString getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_io_LocalizedString_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_io_LocalizedString_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_io_LocalizedString_TranslationsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_io_LocalizedString_TranslationsEntry_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\034io/common/localization.proto\022\002io\"\203\001\n\017L" +
      "ocalizedString\022;\n\014translations\030\001 \003(\0132%.i" +
      "o.LocalizedString.TranslationsEntry\0323\n\021T" +
      "ranslationsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002" +
      " \001(\t:\0028\001*\227\003\n\014LanguageCode\022\006\n\002EN\020\000\022\006\n\002AR\020" +
      "\004\022\013\n\007ZH_HANS\020\010\022\013\n\007ZH_HANT\020\014\022\t\n\005ZH_HK\020\020\022\006" +
      "\n\002CA\020\024\022\006\n\002HR\020\030\022\006\n\002CS\020\034\022\006\n\002DA\020 \022\006\n\002DE\020$\022\t" +
      "\n\005EN_AU\020(\022\t\n\005EN_GB\020,\022\t\n\005EN_CA\0200\022\t\n\005EN_US" +
      "\0204\022\t\n\005EN_IN\0208\022\006\n\002ES\020<\022\n\n\006ES_419\020@\022\006\n\002FI\020" +
      "D\022\006\n\002FR\020H\022\t\n\005FR_CA\020L\022\006\n\002EL\020P\022\006\n\002HE\020T\022\006\n\002" +
      "HI\020X\022\006\n\002HU\020\\\022\006\n\002ID\020`\022\006\n\002IT\020d\022\006\n\002JA\020h\022\006\n\002" +
      "KO\020l\022\006\n\002MS\020p\022\006\n\002MT\020t\022\006\n\002NL\020x\022\006\n\002NB\020|\022\007\n\002" +
      "PL\020\200\001\022\007\n\002PT\020\204\001\022\n\n\005PT_BR\020\210\001\022\007\n\002RO\020\214\001\022\007\n\002R" +
      "U\020\220\001\022\007\n\002SK\020\224\001\022\007\n\002SV\020\230\001\022\007\n\002TH\020\234\001\022\007\n\002TR\020\240\001" +
      "\022\007\n\002UK\020\244\001\022\007\n\002VI\020\250\001BG\n\020com.passkit.grpcZ$" +
      "stash.passkit.com/io/model/sdk/go/io\252\002\014P" +
      "assKit.Grpcb\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_io_LocalizedString_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_io_LocalizedString_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_io_LocalizedString_descriptor,
        new java.lang.String[] { "Translations", });
    internal_static_io_LocalizedString_TranslationsEntry_descriptor =
      internal_static_io_LocalizedString_descriptor.getNestedTypes().get(0);
    internal_static_io_LocalizedString_TranslationsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_io_LocalizedString_TranslationsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
